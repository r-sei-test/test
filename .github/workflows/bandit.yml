# Bandit security scan with least-privilege, pinning, and SARIF upload
# -----------------------------------------------------------------------------
# What this workflow does (big picture, in order):
#   1) Checks out your code with read-only permissions and no persisted creds.
#   2) Sets up a pinned Python toolchain and installs a pinned Bandit version.
#   3) Runs Bandit across your repo, writing results to a SARIF file.
#   4) Publishes that SARIF to GitHub Code Scanning (Security tab).
#   5) Saves a copy of the SARIF as a build artifact for auditing.
#
# Why it's structured this way (principles):
#   • Default-deny permissions: The workflow starts read-only. Jobs/steps elevate ONLY when needed.
#   • Pin everything: Every third-party action is pinned to an exact commit SHA for tamper-resistance.
#   • Guard untrusted PRs: Uses `pull_request` (not `pull_request_target`) so forked code can’t use secrets.
#   • Concurrency: Cancels superseded runs, avoiding CI pile-ups on busy branches/PRs.
#   • Timeouts: Each job/critical step has an upper bound to prevent costly hangs.
#   • Harden network egress: Audit outbound calls now; switch to “block + allowlist” when stable.
#   • Scope checkout credentials: We don’t persist a token into the repo since we won’t push.
#   • Reproducible tools: Fixed runner + pinned Python + pinned Bandit → deterministic results.
#   • Results are auditable: SARIF is uploaded to Code Scanning and kept as an artifact.

name: Bandit

on:
  # Run on main branch changes that affect Python or Bandit config.
  push:
    branches: [ "main" ]
    paths:
      - "**/*.py"
      - "pyproject.toml"
      - "poetry.lock"
      - "requirements*.txt"
      - "setup.cfg"
      - ".bandit"
      - "bandit.yaml"
      - "bandit.yml"
      - ".github/workflows/bandit.yml"
  # Run on PRs targeting main; keeps forked PRs safe (no write scopes exposed).
  pull_request:
    branches: [ "main" ]
    paths:
      - "**/*.py"
      - "pyproject.toml"
      - "poetry.lock"
      - "requirements*.txt"
      - "setup.cfg"
      - ".bandit"
      - "bandit.yaml"
      - "bandit.yml"
      - ".github/workflows/bandit.yml"
  # Optional scheduled run (weekly). Adjust cadence as needed.
  schedule:
    - cron: "37 14 * * 1"
  # Manual trigger if you ever want to click “Run workflow” in the UI.
  workflow_dispatch:

# Cancel older in-flight runs for the same branch/PR to save time and money.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

# Default-deny: grant only read at the workflow level.
permissions:
  contents: read

jobs:
  bandit:
    name: Bandit scan → SARIF
    runs-on: ubuntu-24.04            # Pin runner image for reproducibility
    timeout-minutes: 15              # Upper bound for the whole job

    # Elevate only what this job needs:
    # - contents: read      → for checkout
    # - security-events: write → to upload SARIF to Code Scanning
    # - actions: read       → required in private repos so upload-sarif can read run status
    permissions:
      contents: read
      security-events: write
      actions: read

    # Centralize versions and file paths here for easy maintenance.
    env:
      BANDIT_VERSION: "1.8.6"        # Pinned Bandit version (update intentionally)
      SARIF_OUT: "reports/bandit.sarif"

    steps:
      # Lock down the ephemeral runner’s egress.
      # Start in audit mode to learn which hosts are contacted.
      # Later, switch to `egress-policy: block` + an allowlist (see commented list).
      - name: Harden the runner (Audit outbound egress)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit
          # After a few green runs, prefer:
          # egress-policy: block
          # allowed-endpoints: >
          #   pypi.org:443
          #   files.pythonhosted.org:443
          #   api.github.com:443
          #   uploads.github.com:443
          #   objects.githubusercontent.com:443
          #   github.com:443

      # Check out the repository with minimal privileges.
      # - persist-credentials: false → do not leave a token in .git/config
      # - fetch-depth: 0 → full history (improves blame in some tools; safe default)
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false
          fetch-depth: 0

      # Set up a pinned Python toolchain, with pip caching to speed re-runs.
      # cache-dependency-path covers common dependency files so cache busts on changes.
      - name: Set up Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: "3.12"
          cache: "pip"
          cache-dependency-path: |
            **/requirements*.txt
            **/pyproject.toml
            **/poetry.lock
            **/setup.cfg

      # Install a known Bandit version for reproducibility.
      # Include the [toml] extra so Bandit can read pyproject.toml if you configure it there.
      - name: Install Bandit (pinned)
        run: |
          set -euxo pipefail
          python -m pip install --upgrade pip
          python -m pip install "bandit[toml]==${BANDIT_VERSION}"
          bandit --version
        timeout-minutes: 3

      # Run Bandit recursively from repo root.
      # --format sarif  → output that GitHub Code Scanning can ingest.
      # --exit-zero     → CI stays green; remove this flag to enforce gates.
      # --exclude       → skip common noise (tweak to fit your repo).
      # --severity-level and --confidence-level are set to “all” to capture everything.
      - name: Run Bandit and write SARIF
        run: |
          set -euxo pipefail
          mkdir -p "$(dirname "${SARIF_OUT}")"
          bandit -r . \
            --format sarif \
            --output "${SARIF_OUT}" \
            --severity-level all \
            --confidence-level all \
            --exit-zero \
            --quiet \
            --exclude .git,.venv,venv,.tox,site-packages,dist,build
        timeout-minutes: 5

      # Publish SARIF to GitHub Code Scanning (Security tab).
      # We add a category so Bandit’s findings don’t collide with other tools.
      - name: Upload SARIF to Code Scanning
        uses: github/codeql-action/upload-sarif@3c3833e0f8c1c83d449a7478aa59c036a9165498 # v3.29.11
        with:
          sarif_file: ${{ env.SARIF_OUT }}
          category: bandit

      # Keep an auditable copy of the SARIF in build artifacts with defined retention.
      - name: Upload SARIF as artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: bandit-sarif
          path: ${{ env.SARIF_OUT }}
          retention-days: 14
