# Semgrep (hardened, pinned, least-privilege) — PRs, pushes, manual, nightly
# =============================================================================
# What this workflow does (high level):
#   1) Job "semgrep-scan": installs a pinned Semgrep CLI and runs a scan that
#      always writes SARIF (semgrep.sarif). If a Semgrep App token is present,
#      it uses `semgrep ci` (org policies). Otherwise it uses `semgrep scan`
#      with curated registry rules (`p/ci`). It saves SARIF as an artifact.
#   2) Job "upload-sarif": uploads the SARIF to GitHub Code Scanning.
#
# Why this structure:
#   - Separate jobs: only the uploader gets `security-events: write` (least privilege).
#   - Everything is pinned to commit SHAs for reproducibility and tamper resistance.
#   - Concurrency + timeouts: prevent CI pile-ups and cap spend.
#   - Egress hardening: start in audit; later flip to block + allowlist.
#   - No `latest`; we pin Semgrep to a fixed version.

name: Semgrep

on:
  # Manual button in the Actions tab (good for testing)
  workflow_dispatch: {}

  # Scan proposed changes safely (no secrets shared with forks by default)
  pull_request:
    branches: [ "**" ] # [ "main" ] tune to your repo
    paths:
      - "**/*"                           # narrow to your code paths to cut cost if desired
      - ".github/workflows/semgrep.yml"

  # Cover direct commits to main
  push:
    branches: [ "**" ] # [ "main" ]
    paths:
      - "**/*"
      - ".github/workflows/semgrep.yml"

  # Nightly drift check
  schedule:
    - cron: "16 6 * * *"                 # daily at 06:16 

# Cancel older in-flight runs on the same ref/PR 
concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

# Default-deny at the workflow level (read-only). Jobs elevate minimally.
permissions:
  contents: read

jobs:
  # ────────────────────────────────── Job 1: Scan ──────────────────────────────────
  semgrep-scan:
    name: Semgrep scan -> SARIF
    runs-on: ubuntu-24.04                   # explicit runner for reproducibility
    timeout-minutes: 20

    # Least privilege: only needs to read the repo
    permissions:
      contents: read

    # Central knobs
    env:
      # If set, enables Semgrep App (org policies, triage, PR comments if configured).
      SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
      # Pin the version. Update intentionally during review.
      SEMGREP_VERSION: "1.134.0"
      # SARIF output path (relative to workspace)
      SARIF_FILE: "semgrep.sarif"
      # CWE-enriched SARIF path
      SARIF_ENRICHED_FILE: "semgrep.cwe-tagged.sarif"

    # Expose whether SARIF exists so the upload job can decide to run
    outputs:
      has_local:   ${{ steps.check.outputs.has_local }}
      has_managed: ${{ steps.check.outputs.has_managed }}
      has_any:     ${{ steps.check.outputs.has_any }}


    steps:
      # Harden egress. Start with audit to learn endpoints. Later switch to:
      #   egress-policy: block
      #   allowed-endpoints: >
      #     api.github.com:443
      #     uploads.github.com:443
      #     objects.githubusercontent.com:443
      #     github.com:443
      #     pypi.org:443
      #     files.pythonhosted.org:443
      - name: Harden runner (egress audit)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      # Checkout with no persisted credentials
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false
          fetch-depth: 0                  # full history; useful if rules look at blame/history

      # Set up Python (pinned) so we can install a specific Semgrep version
      - name: Set up Python 
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: "3.12.5"

      - name: Install Semgrep CLI 
        shell: bash
        env:
          PIP_DISABLE_PIP_VERSION_CHECK: "1"
          PIP_INDEX_URL: "https://pypi.org/simple"
        run: |
          set -euo pipefail
          tmp="$(mktemp -d)"

          # 1) Resolve exact artifacts (Semgrep + build tools). Downloads all deps.
          python -m pip download -d "$tmp" "semgrep==${SEMGREP_VERSION}" "setuptools" "wheel"

          # 2) Create two lock files: build tools first, then everything else.
          build="$tmp/build-req.txt"; : > "$build"
          main="$tmp/main-req.txt";  : > "$main"

          # Lock setuptools and wheel so sdists can build offline.
          for n in setuptools wheel; do
            f="$(ls -1 "$tmp"/$n-*.whl 2>/dev/null | sort | tail -n1 || true)"
            if [ -n "$f" ]; then
              h="$(sha256sum "$f" | awk '{print $1}')"
              printf 'file://%s --hash=sha256:%s\n' "$f" "$h" >> "$build"
            fi
          done

          # Lock all remaining artifacts (wheels + sdists). Exclude the build wheels above.
          while IFS= read -r f; do
            base="$(basename "$f")"
            case "$base" in setuptools-*.whl|wheel-*.whl) continue;; esac
            h="$(sha256sum "$f" | awk '{print $1}')"
            printf 'file://%s --hash=sha256:%s\n' "$f" "$h" >> "$main"
          done < <(find "$tmp" -maxdepth 1 -type f \( -name '*.whl' -o -name '*.tar.gz' -o -name '*.zip' \) | sort)

          # 3) Install build tooling first (offline, hash-verified).
          if [ -s "$build" ]; then
            python -m pip install --no-index --require-hashes -r "$build"
          fi

          # 4) Install the rest offline; no build isolation so sdists use the local setuptools/wheel.
          python -m pip install --no-index --require-hashes --no-build-isolation -r "$main"

          semgrep --version
        timeout-minutes: 10

      # Baseline for PRs so Semgrep can focus on diffs (noise reduction).
      # For pushes, skip baseline.
      - name: Determine baseline commit (PRs only)
        id: base
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            git fetch --no-tags origin "${{ github.event.pull_request.base.ref }}":"refs/remotes/origin/${{ github.event.pull_request.base.ref }}" || true
            mb="$(git merge-base "HEAD" "refs/remotes/origin/${{ github.event.pull_request.base.ref }}")" || mb=""
            echo "baseline=${mb}" >> "$GITHUB_OUTPUT"
          else
            echo "baseline=" >> "$GITHUB_OUTPUT"
          fi

      # Run Semgrep and write SARIF.
      # By default Semgrep exits 0 even with findings; to gate merges, add `--error`
      # or configure blocking policies in Semgrep App.
      - name: Run Semgrep -> SARIF (local + managed if token)
        shell: bash
        env:
          SEMGREP_BASELINE_COMMIT: ${{ steps.base.outputs.baseline }}
        run: |
          set -euo pipefail
          mkdir -p reports

          # Always run the local (curated rules) scan
          semgrep scan --config auto \
            --config p/owasp-top-ten \
            --config p/cwe-top-25 \
            --config p/security-audit \
            --config p/secrets \
            ${SEMGREP_BASELINE_COMMIT:+--baseline-commit "$SEMGREP_BASELINE_COMMIT"} \
            --timeout=30 \
            --timeout-threshold=0 \
            --max-target-bytes=0 \
            --dataflow-traces \
            --sarif --output "reports/semgrep.local.sarif" || true

          # If a Semgrep App token is present, also run managed scan (org policies)
          if [[ -n "${SEMGREP_APP_TOKEN:-}" ]]; then
            SEMGREP_APP_TOKEN="$SEMGREP_APP_TOKEN" \
            semgrep ci \
              ${SEMGREP_BASELINE_COMMIT:+--baseline-commit "$SEMGREP_BASELINE_COMMIT"} \
              --sarif --output "reports/semgrep.managed.sarif" || true
          fi

      # Add CWE tags to SARIF from Semgrep rule metadata ONLY (no path/filename inference)
      - name: Enrich SARIF with CWE tags (Semgrep metadata only)
        shell: bash
        run: |
          set -euo pipefail
          python - << 'PY'
          import json, re, os, glob, sys, pathlib
          in_files = [p for p in glob.glob("reports/semgrep.*.sarif") if os.path.getsize(p) > 0]
          if not in_files:
              sys.exit(0)

          def enrich(src, dst):
              with open(src, 'r', encoding='utf-8') as f:
                  sarif = json.load(f)
              # Inject taxonomy tags based solely on Semgrep rule metadata already present in SARIF.
              for run in sarif.get("runs", []):
                  driver = (run.get("tool") or {}).get("driver") or {}
                  for rule in (driver.get("rules") or []):
                      props = rule.setdefault("properties", {})
                      tags  = set(props.get("tags", []))
                      # Pull CWE ids from existing rule tags like "CWE-79" or "CWE-079".
                      cwes = set()
                      for t in list(tags):
                          m = re.search(r"\bCWE-?(\d{1,4})\b", t, re.I)
                          if m: cwes.add(int(m.group(1)))
                      # (Optional) Some Semgrep SARIFs carry metadata in properties.metadata.cwe
                      md = props.get("metadata") if isinstance(props.get("metadata"), dict) else None
                      if md:
                          val = md.get("cwe") or md.get("cwes")
                          vals = val if isinstance(val, list) else ([val] if isinstance(val, str) else [])
                          for v in vals:
                              m = re.search(r"\bCWE-?(\d{1,4})\b", str(v), re.I)
                              if m: cwes.add(int(m.group(1)))
                      # Add GitHub-recognized taxonomy tags
                      for n in sorted(cwes):
                          tags.add(f"external/cwe/cwe-{n:03d}")
                      props["tags"] = sorted(tags)
              pathlib.Path("reports").mkdir(parents=True, exist_ok=True)
              with open(dst, 'w', encoding='utf-8') as f:
                  json.dump(sarif, f, indent=2)

          for src in in_files:
              base = os.path.splitext(src)[0]
              enrich(src, f"{base}.cwe.sarif")
          PY

      # Verify we actually produced a SARIF (guards the upload job)
      - name: Check SARIF exists
        id: check
        shell: bash
        run: |
          set -euo pipefail
          local=false
          managed=false
          [[ -s reports/semgrep.local.cwe.sarif   ]] && local=true
          [[ -s reports/semgrep.managed.cwe.sarif ]] && managed=true
          echo "has_local=$local"     >> "$GITHUB_OUTPUT"
          echo "has_managed=$managed" >> "$GITHUB_OUTPUT"
          echo "has_any=$([[ "$local" == true || "$managed" == true ]] && echo true || echo false)" >> "$GITHUB_OUTPUT"

      # Keep an auditable copy with defined retention
      - name: Upload SARIF as artifact
        if: always() && steps.check.outputs.has_any == 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: semgrep-sarif
          path: |
            reports/semgrep.local.cwe.sarif
            reports/semgrep.managed.cwe.sarif
          if-no-files-found: ignore
          retention-days: 14


  # ────────────────────────────────── Job 2: Upload ──────────────────────────────────
  upload-sarif:
    name: Upload SARIF to Code Scanning
    needs: semgrep-scan
    if: ${{ needs.semgrep-scan.outputs.has_any == 'true' }}
    runs-on: ubuntu-24.04
    timeout-minutes: 10

    # Least privilege: only the uploader can write security events
    permissions:
      contents: read
      security-events: write
      actions: read                      # useful in private repos for status

    steps:
      # Harden egress in the uploader too
      - name: Harden runner (egress audit)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      # Pull the SARIF produced by Job 1
      - name: Download SARIF artifact
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          name: semgrep-sarif
          path: .

      # Upload to the Security tab. Category keeps tools distinct.
      - name: Upload SARIF (local)
        if: ${{ needs.semgrep-scan.outputs.has_local == 'true' }}
        uses: github/codeql-action/upload-sarif@192325c86100d080feab897ff886c34abd4c83a3 # v3.30.3
        with:
          sarif_file: reports/semgrep.local.cwe.sarif
          category: semgrep-local

      - name: Upload SARIF (managed)
        if: ${{ needs.semgrep-scan.outputs.has_managed == 'true' }}
        uses: github/codeql-action/upload-sarif@192325c86100d080feab897ff886c34abd4c83a3 # v3.30.3
        with:
          sarif_file: reports/semgrep.managed.cwe.sarif
          category: semgrep-managed
