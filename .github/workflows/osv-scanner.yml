# OSV-Scanner (hardened, pinned, least-privilege) — PRs, merge-queue, pushes, weekly, manual
# =============================================================================
# What this workflow does:
#   1) Job "osv-scan": installs a pinned OSV-Scanner CLI, scans your dependency manifests
#      recursively, and writes a SARIF report at reports/osv.sarif. It then uploads the SARIF
#      as an artifact (for auditing and the next job).
#   2) Job "upload-sarif": downloads that SARIF and uploads it to GitHub Code Scanning.
#
# Why this layout:
#   • Your previous error came from calling a reusable workflow with job-level `uses:`. Some environments
#     (or older schema validators) will demand `runs-on`. Running the CLI locally avoids that.
#   • Least privilege: only the uploader job gets `security-events: write`.
#   • Pinned actions, explicit runner, concurrency, timeouts, and egress hardening are applied.
#
# Freshman notes:
#   • Update OSV_VERSION below on purpose during maintenance (review the diff).
#   • Narrow the trigger paths to the ecosystems you actually use to save CI minutes.
#   • To block merges on findings, remove the "|| true" softening in the scan step and/or add OSV flags
#     like `--fail-on=all` or `--severity=HIGH,CRITICAL`.

name: OSV-Scanner

on:
  # Scan proposed changes before merge
  pull_request:
    branches: [ "main" ]                     # ← tune to your branching model
    paths:
      # Common dependency files; trim to your ecosystems to reduce cost/noise
      - "**/package.json"
      - "**/package-lock.json"
      - "**/pnpm-lock.yaml"
      - "**/yarn.lock"
      - "**/requirements*.txt"
      - "**/pyproject.toml"
      - "**/poetry.lock"
      - "**/Pipfile.lock"
      - "**/go.mod"
      - "**/go.sum"
      - "**/Cargo.toml"
      - "**/Cargo.lock"
      - "**/pom.xml"
      - "**/build.gradle*"
      - "**/Gemfile.lock"
      - "**/composer.lock"
      - "**/mix.lock"
      - "**/*.csproj"
      - "**/*.fsproj"
      - ".github/workflows/osv-scanner.yml"

  # Merge queue batches (optional)
  merge_group:
    branches: [ "main" ]
    paths:
      - "**/*"
      - ".github/workflows/osv-scanner.yml"

  # Cover direct commits
  push:
    branches: [ "main" ]
    paths:
      - "**/*"
      - ".github/workflows/osv-scanner.yml"

  # Weekly drift check
  schedule:
    - cron: "18 6 * * 1"                     # Mondays 06:18 UTC

  # Manual trigger
  workflow_dispatch: {}

# Cancel superseded runs (prevents CI pile-ups)
concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}
  cancel-in-progress: true

# Default-deny at workflow scope; jobs elevate only what they need
permissions:
  contents: read

jobs:
  # ───────────────────────────────────── Job 1: Scan ─────────────────────────────────────
  osv-scan:
    name: OSV scan → SARIF
    runs-on: ubuntu-24.04                     # explicit runner for reproducibility
    timeout-minutes: 15                       # cap runtime; fail fast
    permissions:
      contents: read                          # only needs to read the repo

    env:
      # Pin OSV-Scanner version intentionally (update on purpose)
      OSV_VERSION: "v1.7.3"
      # Path for the SARIF report
      SARIF_OUT: "reports/osv.sarif"

    steps:
      # Harden egress. Start in 'audit' to learn endpoints; later switch to 'block' + allowlist:
      #   api.github.com:443, uploads.github.com:443, objects.githubusercontent.com:443, github.com:443
      - name: Harden runner (egress audit)
        uses: step-security/harden-runner@ec9f2d5744a09debf3a187a3f4f675c53b671911 # v2.13.0
        with:
          egress-policy: audit

      # Checkout with no persisted credentials (we never push here)
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          persist-credentials: false
          fetch-depth: 0

      # Prepare output directory
      - name: Prepare reports directory
        shell: bash
        run: mkdir -p reports

      # Install a pinned OSV-Scanner CLI release (Linux x86_64).
      # Freshman tip: this downloads a single binary and moves it into /usr/local/bin.
      # If your runner arch differs, adjust the artifact name accordingly.
      - name: Install OSV-Scanner (pinned)
        shell: bash
        run: |
          set -euo pipefail
          cd "$(mktemp -d)"
          # Download tarball for pinned version
          curl -fsSL -o osv.tar.gz "https://github.com/google/osv-scanner/releases/download/${OSV_VERSION}/osv-scanner_${OSV_VERSION#v}_linux_amd64.tar.gz"
          tar -xzf osv.tar.gz
          sudo mv osv-scanner /usr/local/bin/osv-scanner
          chmod +x /usr/local/bin/osv-scanner
          osv-scanner --version

      # Run OSV-Scanner recursively, skip .git, and write SARIF.
      # "|| true" ensures we still upload SARIF even if findings or non-zero exits occur.
      # Remove "|| true" (and/or add --fail-on=all) if you want the job to fail on vulns.
      - name: Run OSV-Scanner → SARIF
        shell: bash
        run: |
          set -euo pipefail
          osv-scanner \
            -r \
            --skip-git \
            ./ \
            --format sarif \
            --output "${SARIF_OUT}" \
          || true
          test -s "${SARIF_OUT}" || (echo "No SARIF produced"; exit 1)

      # Keep an auditable copy for 14 days and for the next job
      - name: Upload SARIF artifact
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: osv-sarif
          path: ${{ env.SARIF_OUT }}
          retention-days: 14

  # ─────────────────────────────────── Job 2: Uplo
